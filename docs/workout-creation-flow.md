# Flow de Cr√©ation d'un Workout

Ce document illustre le parcours complet d'une requ√™te de cr√©ation de workout, depuis le formulaire frontend jusqu'√† la base de donn√©es, en passant par toutes les couches de l'architecture Clean Architecture.

## Diagramme de S√©quence

```mermaid
sequenceDiagram
  actor User as Utilisateur
  participant Form as Client Web
  participant API as NestJS API
  participant AuthG as AuthGuard
  participant Controller as WorkoutController
  participant PermG as PermissionsGuard
  participant UseCase as WorkoutUseCases
  participant Repo as WorkoutRepository
  participant DB as PostgreSQL

  User->>Form: Remplit le formulaire<br/>(title, category, elements)
  Form->>Form: createWorkout(data)
  Form->>API: POST /api/workout<br/>
  API->>AuthG: V√©rifie l'authentification
  AuthG-->>API: ‚úì User authentifi√©
  API->>Controller: Route vers handler
  Controller->>Controller: safeParse(body)<br/>(Validation Zod)
  Controller->>PermG: V√©rifie les permissions
  PermG->>PermG: R√©cup√®re r√¥le dans l'org<br/>
  PermG-->>Controller: ‚úì Permission accord√©e<br/>
  Controller->>UseCase: createWorkout(body, orgId, userId)
  UseCase->>UseCase: V√©rifications m√©tiers
  UseCase->>UseCase: Cr√©e entit√©s (workout + elements)
  UseCase->>Repo: save(workout)
  Repo->>DB: INSERT workout + elements<br/>(transaction atomique)
  DB-->>Repo: ‚úì Workout cr√©√©
  Repo-->>UseCase: Workout cr√©√©
  UseCase->>Repo: getOneWithDetails(id, coachFilterConditions)
  Repo->>DB: SELECT avec JOINs<br/>WHERE createdBy IN (coaches)
  DB-->>Repo: Workout complet
  Repo-->>UseCase: Workout avec toutes les relations
  UseCase-->>Controller: Workout cr√©√©
  Controller->>Controller: Mapper.toDto(workout)
  Controller->>Controller: Presenter.presentOne(dto)
  Controller-->>Form: 201 Created + WorkoutDto
  Form->>Form: Workout cr√©√©
  Form->>User: Redirection + Toast de succ√®s
```

## Snippets de Code Simplifi√©s

### 1. Frontend - Formulaire de Cr√©ation

```typescript
// apps/web/src/routes/__home.workouts.create.tsx
import { api } from '@/lib/api';  // Client ts-rest g√©n√©r√© depuis le contract
import type { CreateWorkout } from '@dropit/schemas';  // Type Zod partag√©

function CreateWorkoutPage() {
  const { mutate: createWorkoutMutation } = useMutation({
    mutationFn: async (data: CreateWorkout) => {
      // üõ°Ô∏è PROTECTION XSS:
      // - React √©chappe automatiquement les donn√©es dans le JSX
      // - Pas de dangerouslySetInnerHTML utilis√©

      // üõ°Ô∏è PROTECTION CSRF:
      // - better-auth envoie automatiquement les cookies httpOnly
      // - Cookies avec attribut SameSite=Lax

      // üõ°Ô∏è TYPE-SAFETY:
      // - CreateWorkout vient du package @dropit/schemas (voir snippet 3)
      // - api.workout vient du package @dropit/contract (voir snippet 2)
      // - ts-rest garantit le typage end-to-end

      const response = await api.workout.createWorkout({ body: data });
      if (response.status !== 201) {
        throw new Error('Erreur lors de la cr√©ation');
      }
      return response.body;
    },
    onSuccess: (workout) => {
      toast({ title: 'Succ√®s', description: 'Entra√Ænement cr√©√©' });
      navigate({ to: `/workouts/${workout.id}` });
    }
  });

  return <WorkoutCreationStepper onSuccess={createWorkoutMutation} />;
}
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **XSS (Cross-Site Scripting)** : React √©chappe automatiquement le contenu
- ‚úÖ **CSRF (Cross-Site Request Forgery)** : Cookies httpOnly + SameSite
- ‚úÖ **Man-in-the-Middle** : Communication HTTPS uniquement en production

### 2. Contract - D√©finition API avec ts-rest

```typescript
// packages/contract/src/workout.contract.ts
export const workoutContract = {
  createWorkout: {
    method: 'POST',
    path: '/workout',
    summary: 'Create a workout',
    body: createWorkoutSchema,  // üõ°Ô∏è Validation Zod obligatoire
    responses: {
      201: workoutSchema,       // üõ°Ô∏è Type de retour garanti
      400: z.object({ message: z.string() }),
      401: z.object({ message: z.string() }),  // Unauthorized
      403: z.object({ message: z.string() }),  // Forbidden
    },
  },
} as const;
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **Type Safety** : Contrat partag√© entre frontend et backend
- ‚úÖ **API Contract Validation** : Impossible d'envoyer des donn√©es non conformes
- ‚úÖ **Documentation automatique** : Le contrat documente les erreurs possibles

### 3. Validation Zod - Sch√©ma de Donn√©es

```typescript
// packages/schemas/src/workout.schema.ts
export const createWorkoutSchema = z.object({
  // üõ°Ô∏è PROTECTION MASS ASSIGNMENT:
  // Seuls les champs d√©finis sont accept√©s, impossible d'injecter
  // des champs comme "isAdmin: true" ou "organizationId: 'autre-org'"

  title: z.string().min(1).max(200),  // üõ°Ô∏è Limite la taille
  workoutCategory: z.string().uuid(), // üõ°Ô∏è Validation format UUID
  description: z.string().max(1000).optional(),  // üõ°Ô∏è Limite DoS
  elements: z.array(createWorkoutElementSchema).min(1).max(50), // üõ°Ô∏è Limite
  trainingSession: z.object({
    athleteIds: z.array(z.string().uuid()).max(100),  // üõ°Ô∏è Limite
    scheduledDate: z.string().datetime(),  // üõ°Ô∏è Validation format
  }).optional(),
});

const createWorkoutElementSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('exercise'),
    id: z.string().uuid(),  // üõ°Ô∏è Format UUID
    sets: z.number().int().min(1).max(100),  // üõ°Ô∏è Limites
    reps: z.number().int().min(1).max(1000),
    rest: z.number().int().min(0).max(600).optional(),  // Max 10min
    // ...
  }),
  z.object({
    type: z.literal('complex'),
    // ... m√™mes validations
  }),
]);
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **Mass Assignment** : Whitelist stricte des champs accept√©s
- ‚úÖ **NoSQL/SQL Injection** : Validation de format (UUID, datetime)
- ‚úÖ **DoS (Denial of Service)** : Limites de taille sur arrays et strings
- ‚úÖ **Buffer Overflow** : Contraintes min/max sur les nombres
- ‚úÖ **Input Validation** : Types stricts et formats valid√©s

### 4. Controller - Point d'Entr√©e Backend

```typescript
// apps/api/src/modules/training/interface/controllers/workout.controller.ts

// üõ°Ô∏è PROTECTION BROKEN ACCESS CONTROL:
// PermissionsGuard v√©rifie que l'utilisateur a les permissions requises
@UseGuards(PermissionsGuard)
@Controller()
export class WorkoutController {
  constructor(private readonly workoutUseCases: IWorkoutUseCases) {}

  // üõ°Ô∏è RBAC (Role-Based Access Control):
  // Seuls les roles admin/owner ont la permission "create" sur "workout"
  @TsRestHandler(workoutContract.createWorkout)
  @RequirePermissions('create')
  createWorkout(
    @CurrentOrganization() organizationId: string,  // üõ°Ô∏è Inject√© par AuthGuard
    @CurrentUser() user: AuthenticatedUser          // üõ°Ô∏è User v√©rifi√©
  ) {
    // üõ°Ô∏è VALIDATION ZOD RUNTIME:
    // tsRestHandler() intercepte la requ√™te et ex√©cute:
    //   const result = createWorkoutSchema.safeParse(req.body);
    //   if (!result.success) return { status: 400, body: result.error };
    //
    // Ici, dans le handler, body est D√âJ√Ä valid√© et typ√©

    return tsRestHandler(workoutContract.createWorkout, async ({ body }) => {
      // üõ°Ô∏è LAYERS DE S√âCURIT√â D√âJ√Ä PASS√âES:
      // 1. AuthGuard (global) ‚Üí User authentifi√© via session better-auth
      // 2. tsRestHandler ‚Üí Body valid√© avec Zod (runtime)
      // 3. PermissionsGuard ‚Üí R√¥le v√©rifi√© (admin ou owner)

      // üõ°Ô∏è PROTECTION PRIVILEGE ESCALATION:
      // organizationId vient de la session, pas du client
      // Impossible de cr√©er un workout pour une autre organisation

      const workout = await this.workoutUseCases.createWorkout(
        body,              // Type: CreateWorkout (valid√© par Zod)
        organizationId,    // üõ°Ô∏è Valeur trust√©e de la session
        user.id
      );

      // Mapping entit√© ‚Üí DTO (√©vite d'exposer des donn√©es sensibles)
      const workoutDto = WorkoutMapper.toDto(workout);

      // Pr√©sentation (status code + body)
      return WorkoutPresenter.presentOne(workoutDto);
    });
  }
}
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **Broken Authentication** : AuthGuard global v√©rifie la session better-auth
- ‚úÖ **Input Validation** : tsRestHandler valide le body avec Zod au runtime (safeParse)
- ‚úÖ **Broken Access Control** : PermissionsGuard v√©rifie les droits RBAC
- ‚úÖ **Privilege Escalation** : organizationId extrait de la session, pas du client
- ‚úÖ **Parameter Tampering** : Param√®tres critiques inject√©s par les decorators
- ‚úÖ **Session Fixation** : better-auth g√®re la rotation des sessions

### 5. Use Case - Logique M√©tier

```typescript
// apps/api/src/modules/training/application/use-cases/workout.use-cases.ts
export class WorkoutUseCases implements IWorkoutUseCases {
  constructor(
    private readonly em: EntityManager,  // Inject√© pour Unit of Work
    // ... autres d√©pendances
  ) {}

  async createWorkout(
    workout: CreateWorkout,
    organizationId: string,
    userId: string
  ): Promise<Workout> {
    // üõ°Ô∏è PROTECTION IDOR (Insecure Direct Object Reference):
    // coachFilterConditions limite l'acc√®s aux ressources de l'organisation
    const coachFilterConditions = await this.memberUseCases.getCoachFilterConditions(
      organizationId
    );

    // Validation m√©tier (r√®gles business)
    if (!workout.elements || workout.elements.length === 0) {
      throw new WorkoutValidationException('Au moins un √©l√©ment requis');
    }

    // üõ°Ô∏è PROTECTION IDOR:
    // V√©rifie que la cat√©gorie appartient √† l'organisation
    const category = await this.workoutCategoryRepository.getOne(
      workout.workoutCategory,
      coachFilterConditions
    );
    if (!category) {
      throw new WorkoutCategoryNotFoundException('Cat√©gorie introuvable');
    }

    // üõ°Ô∏è PROTECTION DATA INTEGRITY - Unit of Work Pattern:
    // Toutes les op√©rations ci-dessous sont dans l'Unit of Work (m√©moire)
    // Aucune requ√™te SQL n'est ex√©cut√©e tant qu'on ne fait pas flush()
    // Si UNE op√©ration √©choue ‚Üí ROLLBACK AUTOMATIQUE de TOUTES les op√©rations

    // Cr√©ation de l'entit√© Workout
    const workoutToCreate = new Workout();
    workoutToCreate.title = workout.title;
    workoutToCreate.description = workout.description || '';
    workoutToCreate.category = category;
    workoutToCreate.createdBy = await this.userUseCases.getOne(userId);

    // Enregistre dans l'Unit of Work (PAS encore en DB)
    this.em.persist(workoutToCreate);

    // üõ°Ô∏è PROTECTION IDOR SUR LES √âL√âMENTS:
    // V√©rifie que les exercises/complexes appartiennent √† l'organisation
    for (const element of workout.elements) {
      const workoutElement = new WorkoutElement();
      workoutElement.type = element.type;
      workoutElement.sets = element.sets;
      workoutElement.reps = element.reps;

      if (element.type === 'exercise') {
        const exercise = await this.exerciseRepository.getOne(
          element.id,
          coachFilterConditions
        );
        if (!exercise) throw new ExerciseNotFoundException();
        workoutElement.exercise = exercise;
      } else {
        const complex = await this.complexRepository.getOne(
          element.id,
          coachFilterConditions
        );
        if (!complex) throw new ComplexNotFoundException();
        workoutElement.complex = complex;
      }

      workoutElement.workout = workoutToCreate;

      // Enregistre dans l'Unit of Work (PAS encore en DB)
      this.em.persist(workoutElement);
    }

    // Optionnel: Cr√©ation d'une session d'entra√Ænement
    if (workout.trainingSession) {
      const trainingSession = new TrainingSession();
      trainingSession.workout = workoutToCreate;
      trainingSession.scheduledDate = new Date(
        workout.trainingSession.scheduledDate
      );
      this.em.persist(trainingSession);

      for (const athleteId of workout.trainingSession.athleteIds) {
        const athlete = await this.athleteRepository.getOne(athleteId);
        if (!athlete) throw new AthleteNotFoundException();

        const athleteSession = new AthleteTrainingSession();
        athleteSession.athlete = athlete;
        athleteSession.trainingSession = trainingSession;
        this.em.persist(athleteSession);
      }
    }

    // üõ°Ô∏è TRANSACTION ATOMIQUE:
    // flush() ex√©cute TOUTES les requ√™tes SQL en une seule transaction:
    // BEGIN;
    //   INSERT INTO workout VALUES (...);           -- G√©n√®re UUID
    //   INSERT INTO workout_element VALUES (...);   -- Utilise l'UUID
    //   INSERT INTO workout_element VALUES (...);   -- Utilise l'UUID
    //   INSERT INTO training_session VALUES (...);
    //   INSERT INTO athlete_training_session VALUES (...);
    // COMMIT;
    //
    // Si UNE SEULE requ√™te √©choue ‚Üí ROLLBACK de TOUT
    // Garantit l'int√©grit√©: soit tout est cr√©√©, soit rien
    await this.em.flush();

    // R√©cup√©ration du workout avec toutes ses relations
    // (pour envoyer les donn√©es compl√®tes au frontend)
    return await this.workoutRepository.getOneWithDetails(
      workoutToCreate.id,
      coachFilterConditions
    );
  }
}
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **IDOR (Insecure Direct Object Reference)** : Filtrage syst√©matique par organisation
- ‚úÖ **Horizontal Privilege Escalation** : Impossible d'acc√©der aux ressources d'autres orgs
- ‚úÖ **Business Logic Bypass** : Validations m√©tier strictes
- ‚úÖ **Data Integrity** : Transaction atomique via Unit of Work (rollback automatique si erreur)
- ‚úÖ **Partial Updates** : Impossible d'avoir un workout avec seulement 3/10 √©l√©ments

### 6. Repository - Acc√®s aux Donn√©es

```typescript
// apps/api/src/modules/training/infrastructure/mikro-workout.repository.ts
export class MikroWorkoutRepository implements IWorkoutRepository {
  constructor(private readonly em: EntityManager) {}

  async save(workout: Workout): Promise<Workout> {
    // üõ°Ô∏è PROTECTION SQL INJECTION:
    // MikroORM utilise des requ√™tes param√©tr√©es automatiquement
    // Exemple g√©n√©r√©: INSERT INTO workout (title, description, category_id)
    //                 VALUES ($1, $2, $3)
    // Les valeurs sont pass√©es s√©par√©ment, jamais concat√©n√©es dans la requ√™te

    await this.em.persistAndFlush(workout);
    return workout;
  }

  async getOneWithDetails(
    id: string,
    coachFilterConditions: CoachFilterConditions
  ): Promise<Workout | null> {
    // üõ°Ô∏è PROTECTION SQL INJECTION:
    // Requ√™te g√©n√©r√©e: SELECT * FROM workout
    //                  WHERE id = $1
    //                  AND (created_by_id IS NULL OR created_by_id IN ($2, $3, ...))

    // üõ°Ô∏è PROTECTION IDOR:
    // coachFilterConditions force le filtrage par organisation
    // Impossible de r√©cup√©rer un workout d'une autre organisation

    return await this.em.findOne(
      Workout,
      {
        id,                           // üõ°Ô∏è Param√®tre $1
        $or: coachFilterConditions.$or  // üõ°Ô∏è Param√®tres $2, $3, ...
      },
      {
        // üõ°Ô∏è PROTECTION N+1 QUERIES:
        // Eager loading √©vite les requ√™tes multiples
        populate: [
          'category',
          'elements',
          'elements.exercise',
          'elements.exercise.exerciseCategory',
          'elements.complex',
          'elements.complex.complexCategory',
          'createdBy'
        ],
      }
    );
  }
}
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **SQL Injection** : Requ√™tes param√©tr√©es via MikroORM (prepared statements)
- ‚úÖ **IDOR** : Filtrage syst√©matique avec coachFilterConditions
- ‚úÖ **Performance (DoS)** : Eager loading √©vite les N+1 queries
- ‚úÖ **Data Exposure** : Seules les relations n√©cessaires sont charg√©es

### 7. Entity - Mod√®le de Domaine

```typescript
// apps/api/src/modules/training/domain/workout.entity.ts
@Entity()
export class Workout {
  // üõ°Ô∏è PROTECTION IDOR / ENUMERATION:
  // UUID au lieu d'auto-increment emp√™che la pr√©diction des IDs
  // Impossible de deviner: /api/workout/550e8400-e29b-41d4-a716-446655440000
  @PrimaryKey({ type: 'uuid', defaultRaw: 'gen_random_uuid()' })
  id!: string;

  @Property()
  title!: string;

  @Property()
  description!: string;

  @ManyToOne(() => WorkoutCategory)
  category!: WorkoutCategory;

  // üõ°Ô∏è AUDIT TRAIL:
  // Tra√ßabilit√© de qui a cr√©√© la ressource
  @ManyToOne(() => User, { nullable: true, deleteRule: 'cascade' })
  createdBy!: User | null;

  @OneToMany(() => WorkoutElement, element => element.workout)
  elements = new Collection<WorkoutElement>(this);

  @OneToMany(() => TrainingSession, session => session.workout)
  trainingSessions = new Collection<TrainingSession>(this);

  // üõ°Ô∏è AUDIT TRAIL:
  // Timestamps automatiques pour la tra√ßabilit√©
  @Property({ onCreate: () => new Date() })
  createdAt: Date = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt: Date = new Date();
}
```

**Failles de s√©curit√© contr√©es** :
- ‚úÖ **Insecure Direct Object Reference** : UUID non-pr√©dictible vs auto-increment
- ‚úÖ **Enumeration Attack** : Impossible de scanner les IDs s√©quentiellement
- ‚úÖ **Audit Trail** : createdBy + timestamps pour la tra√ßabilit√©
- ‚úÖ **Data Integrity** : Relations enforced au niveau DB (foreign keys)

## R√©capitulatif des Protections de S√©curit√©

### OWASP Top 10 (2021) - Protections Impl√©ment√©es

| Vuln√©rabilit√© | Protection Impl√©ment√©e | Couche |
|---------------|------------------------|--------|
| **A01:2021 ‚Äì Broken Access Control** | AuthGuard global + PermissionsGuard RBAC | Controller |
| **A02:2021 ‚Äì Cryptographic Failures** | HTTPS + cookies httpOnly + SameSite | Infrastructure |
| **A03:2021 ‚Äì Injection** | Validation Zod + MikroORM parameterized queries | Validation + Repository |
| **A04:2021 ‚Äì Insecure Design** | Clean Architecture + Domain-Driven Design | Architecture |
| **A05:2021 ‚Äì Security Misconfiguration** | CORS configur√© + trusted origins + env vars | Configuration |
| **A06:2021 ‚Äì Vulnerable Components** | Dependencies scann√©es + mises √† jour r√©guli√®res | DevOps |
| **A07:2021 ‚Äì Authentication Failures** | better-auth + session management + rotation | AuthGuard |
| **A08:2021 ‚Äì Data Integrity Failures** | Validation Zod + transactions MikroORM | Validation + Repository |
| **A09:2021 ‚Äì Logging Failures** | Audit trail (createdBy, timestamps) | Entity |
| **A10:2021 ‚Äì SSRF** | Pas de requ√™tes externes bas√©es sur input user | N/A |

### Defense in Depth - Couches de S√©curit√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Frontend (React)                                         ‚îÇ
‚îÇ    üõ°Ô∏è XSS Protection (auto-escaping)                        ‚îÇ
‚îÇ    üõ°Ô∏è Validation Zod c√¥t√© client (UX)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Transport (HTTPS)                                        ‚îÇ
‚îÇ    üõ°Ô∏è Encryption en transit                                 ‚îÇ
‚îÇ    üõ°Ô∏è CSRF Protection (cookies SameSite)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. API Gateway (NestJS)                                     ‚îÇ
‚îÇ    üõ°Ô∏è CORS Configuration                                    ‚îÇ
‚îÇ    üõ°Ô∏è Rate Limiting (TODO)                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. AuthGuard (Global)                                       ‚îÇ
‚îÇ    üõ°Ô∏è Session Validation (better-auth)                      ‚îÇ
‚îÇ    üõ°Ô∏è Cookie httpOnly verification                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. PermissionsGuard (Controller)                            ‚îÇ
‚îÇ    üõ°Ô∏è RBAC (member/admin/owner)                             ‚îÇ
‚îÇ    üõ°Ô∏è Resource-based permissions                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. Validation (Zod)                                         ‚îÇ
‚îÇ    üõ°Ô∏è Input Validation                                      ‚îÇ
‚îÇ    üõ°Ô∏è Mass Assignment Prevention                            ‚îÇ
‚îÇ    üõ°Ô∏è DoS Prevention (size limits)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 7. Use Case (Business Logic)                                ‚îÇ
‚îÇ    üõ°Ô∏è IDOR Prevention (coachFilterConditions)               ‚îÇ
‚îÇ    üõ°Ô∏è Business Rules Enforcement                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 8. Repository (Data Access)                                 ‚îÇ
‚îÇ    üõ°Ô∏è SQL Injection Prevention (parameterized queries)      ‚îÇ
‚îÇ    üõ°Ô∏è N+1 Query Prevention (eager loading)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 9. Database (PostgreSQL)                                    ‚îÇ
‚îÇ    üõ°Ô∏è Foreign Keys Constraints                              ‚îÇ
‚îÇ    üõ°Ô∏è UUID vs Auto-increment                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Failles Sp√©cifiques Contr√©es

#### 1. Injection Attacks
- **SQL Injection** : MikroORM avec requ√™tes param√©tr√©es
- **NoSQL Injection** : Validation Zod des formats (UUID, datetime)
- **Command Injection** : Pas d'ex√©cution de commandes syst√®me
- **Template Injection** : React auto-escaping

#### 2. Broken Authentication & Session
- **Session Fixation** : better-auth avec rotation de session
- **Weak Password** : Gestion par better-auth (bcrypt)
- **No Session Timeout** : Gestion par better-auth
- **Insecure Cookie** : httpOnly + Secure + SameSite=Lax

#### 3. Access Control
- **Horizontal Privilege Escalation** : coachFilterConditions par organisation
- **Vertical Privilege Escalation** : RBAC strict (member/admin/owner)
- **IDOR** : Filtrage syst√©matique + UUID non-pr√©dictibles
- **Path Traversal** : Validation des IDs (UUID format)

#### 4. Data Validation
- **Mass Assignment** : Whitelist Zod (seuls les champs d√©finis accept√©s)
- **Type Confusion** : TypeScript strict + Zod runtime validation
- **Buffer Overflow** : Limites min/max sur tous les champs
- **XXE (XML)** : Pas d'XML parsing

#### 5. Business Logic
- **Race Condition** : Transactions MikroORM
- **Enumeration** : UUID vs auto-increment
- **Resource Exhaustion** : Limites sur arrays (.max(50))

#### 6. Cross-Site Attacks
- **XSS (Reflected/Stored)** : React auto-escaping
- **CSRF** : Cookies SameSite + httpOnly
- **Clickjacking** : X-Frame-Options (TODO)
- **CORS Misconfiguration** : Whitelist des origins

## Points Cl√©s de l'Architecture

### S√©paration des Responsabilit√©s

1. **Frontend (React + TanStack)**
   - Gestion de l'UI et de l'√©tat local
   - Appels API typ√©s avec ts-rest
   - Pas de logique m√©tier

2. **Contract (ts-rest)**
   - D√©finition du contrat API
   - Type-safety entre frontend et backend
   - Validation Zod partag√©e

3. **Controller (NestJS)**
   - Point d'entr√©e HTTP
   - Validation des permissions
   - D√©l√©gation au use case

4. **Use Case (Business Logic)**
   - Logique m√©tier pure (framework-agnostic)
   - Orchestration des op√©rations
   - R√®gles de validation m√©tier

5. **Repository (Infrastructure)**
   - Abstraction de la persistance
   - Requ√™tes SQL via MikroORM
   - Impl√©mentation de l'interface du port

6. **Entity (Domain)**
   - Mod√®le de donn√©es
   - Relations ORM
   - Pas de logique

### Syst√®me d'Authentification et Autorisation (2 Guards)

#### 1. AuthGuard (Global - APP_GUARD)

Appliqu√© automatiquement sur **toutes les routes** :

```typescript
// apps/api/src/modules/identity/identity.module.ts
{
  provide: APP_GUARD,
  useClass: AuthGuard,
}
```

**Responsabilit√©s** :
- ‚úÖ V√©rifie la session better-auth via les cookies httpOnly
- ‚úÖ Extrait `user` et `organizationId` de la session
- ‚úÖ Injecte ces donn√©es dans la requ√™te (`@CurrentUser`, `@CurrentOrganization`)
- ‚úÖ Rejette les requ√™tes non authentifi√©es (401 Unauthorized)
- ‚úÖ Supporte `@Public()` pour les routes publiques (login, register)

#### 2. PermissionsGuard (Controller-level)

Appliqu√© sur les **controllers sp√©cifiques** avec `@UseGuards(PermissionsGuard)` :

**Responsabilit√©s** :
- ‚úÖ R√©cup√®re le **r√¥le** de l'utilisateur dans l'organisation (member/admin/owner)
- ‚úÖ V√©rifie la **permission requise** sur la **ressource**
- ‚úÖ Rejette si l'utilisateur n'a pas la permission (403 Forbidden)

**D√©finition des Permissions** (`@dropit/permissions`) :
```typescript
// Seuls admin et owner ont acc√®s √† "workout"
export const admin = ac.newRole({
  workout: ["read", "create", "update", "delete"],
  exercise: ["read", "create", "update", "delete"],
  // ...
});

export const owner = ac.newRole({
  workout: ["read", "create", "update", "delete"],
  // ... (toutes les permissions)
});

// member (athl√®te) n'a PAS acc√®s √† "workout"
export const member = ac.newRole({
  athlete: ["read", "create", "update", "delete"],
  session: ["read"],
  // PAS de permissions sur "workout"
});
```

**Exemple d'utilisation** :
```typescript
@UseGuards(PermissionsGuard)  // Active le guard
@Controller()
export class WorkoutController {
  @RequirePermissions('create')  // V√©rifie la permission "create" sur "workout"
  createWorkout() { ... }
}
```

#### Pourquoi 2 Guards S√©par√©s ?

**S√©paration des pr√©occupations** :
1. **AuthGuard** : "Qui es-tu ?" ‚Üí Authentification
2. **PermissionsGuard** : "Que peux-tu faire ?" ‚Üí Autorisation

**Avantages** :
- ‚úÖ R√©utilisabilit√© : AuthGuard global, PermissionsGuard cibl√©
- ‚úÖ Flexibilit√© : Routes publiques possibles avec `@Public()`
- ‚úÖ Performance : AuthGuard ne fait qu'une requ√™te session, PermissionsGuard une requ√™te Member
- ‚úÖ Lisibilit√© : Intentions claires dans le code

#### Pourquoi Pas de V√©rification dans le Use Case ?

Le PermissionsGuard **garantit d√©j√†** que seuls les coaches (admin/owner) acc√®dent aux endpoints `workout`.

V√©rifier √† nouveau `isUserCoachInOrganization` dans le use case serait :
- ‚ùå **Redondant** : Requ√™te DB suppl√©mentaire inutile
- ‚ùå **Moins performant** : +50-100ms par requ√™te
- ‚ùå **Violation SRP** : Le use case fait de l'autorisation au lieu de logique m√©tier

‚úÖ **Le use case se concentre sur la logique m√©tier pure** : validation des r√®gles business, orchestration, cr√©ation d'entit√©s.

### Flux de Validation √† 3 Niveaux

1. **Client-side** : Validation Zod avant l'envoi (UX)
2. **API Contract** : Validation Zod √† la r√©ception (S√©curit√©)
3. **Business Logic** : Validation m√©tier dans le use case (R√®gles m√©tier)

### Inversion de D√©pendance

- Use Cases d√©pendent des **interfaces** (ports), pas des impl√©mentations
- Repository impl√©mente l'interface d√©finie dans la couche application
- Framework (NestJS) injecte les d√©pendances concr√®tes

## Technologies Utilis√©es

- **Frontend** : React, TanStack Router, TanStack Query
- **API Contract** : ts-rest, Zod
- **Backend** : NestJS, TypeScript
- **ORM** : MikroORM
- **Database** : PostgreSQL
- **Architecture** : Clean Architecture + DDD
